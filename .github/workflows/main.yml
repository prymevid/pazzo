name: Stream Music Video to YouTube

env:
  # Video file configuration
  VIDEO_FILE_PREFIX: "k"
  VIDEO_FILE_RANGE_START: 1
  VIDEO_FILE_RANGE_END: 30
  VIDEO_FILE_EXTENSION: ".mp4"

  # Stream configuration
  CLOUDFLARE_R2_URL: "https://pub-b19fa9b28a6640638cebf21d187c3e25.r2.dev/english/"
  YOUTUBE_RTMP_URL: "rtmp://a.rtmp.youtube.com/live2/"
  
  # TWO YouTube stream keys
  YOUTUBE_STREAM_KEY_A: "yyz1-w50g-u0gx-yufk-bt7b"
  YOUTUBE_STREAM_KEY_B: "0vky-mmwa-v8t9-j5x0-d6cj"

  # Runtime configuration (minutes)
  BASE_RUNTIME: 20000
  START_JITTER_MAX: 3
  END_JITTER_MAX: 10

  # YouTube preparation delay (seconds)
  YOUTUBE_PREP_DELAY: 10

  # FFmpeg settings
  VIDEO_CODEC: "libx264"
  VIDEO_PRESET: "veryfast"
  VIDEO_BITRATE: "1500k"
  BUFFER_SIZE: "3000k"
  AUDIO_CODEC: "aac"
  AUDIO_BITRATE: "96k"
  AUDIO_SAMPLE_RATE: "44100"
  AUDIO_CHANNELS: "2"

on:
  workflow_dispatch:

jobs:
  stream:
    runs-on: ubuntu-latest
    concurrency:
      group: youtube-stream-group
      cancel-in-progress: true

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          # Force fetch to ensure we have latest key state
          fetch-tags: false

      - name: üîë Select which key to use (Auto-toggle A‚ÜîB) - REINFORCED
        id: select-key
        run: |
          echo "========================================"
          echo "üîë STREAM KEY SELECTION PHASE - REINFORCED"
          echo "========================================"
          
          # DEFINE ALL POSSIBLE KEY FILE NAMES (includes your mentioned file name)
          KEY_FILE_NAMES=("last_stream_key.txt" "last_key_stream.txt" "stream_key_state.txt")
          
          # Initialize with default
          SELECTED_KEY_FILE="last_stream_key.txt"
          FOUND_KEY=""
          
          # Check all possible key files
          for key_file in "${KEY_FILE_NAMES[@]}"; do
            if [ -f "$key_file" ]; then
              echo "‚ÑπÔ∏è  Found key file: $key_file"
              SELECTED_KEY_FILE="$key_file"
              FOUND_KEY=$(cat "$key_file")
              echo "‚ÑπÔ∏è  Content: $FOUND_KEY"
              break
            fi
          done
          
          # If no key file found, create the primary one
          if [ -z "$FOUND_KEY" ]; then
            echo "‚ö†Ô∏è  No existing key file found. Creating new key file..."
            echo "KEY_A" > last_stream_key.txt
            SELECTED_KEY_FILE="last_stream_key.txt"
            FOUND_KEY="KEY_A"
            
            # Also create backup files to ensure consistency
            for key_file in "${KEY_FILE_NAMES[@]}"; do
              echo "$FOUND_KEY" > "$key_file"
            done
            echo "‚úÖ Created all key files with default: KEY_A"
          else
            echo "‚úÖ Using key file: $SELECTED_KEY_FILE with value: $FOUND_KEY"
          fi
          
          # Validate the key value
          if [[ "$FOUND_KEY" != "KEY_A" && "$FOUND_KEY" != "KEY_B" ]]; then
            echo "‚ö†Ô∏è  Invalid key value found: '$FOUND_KEY'. Resetting to KEY_A"
            FOUND_KEY="KEY_A"
            # Update all key files to ensure consistency
            for key_file in "${KEY_FILE_NAMES[@]}"; do
              echo "$FOUND_KEY" > "$key_file"
            done
          fi
          
          # Determine which key to use (alternate between A and B)
          if [ "$FOUND_KEY" = "KEY_A" ]; then
            CURRENT_KEY="KEY_B"
            YOUTUBE_STREAM_KEY="$YOUTUBE_STREAM_KEY_B"
            echo "üîÑ Switching from KEY_A to KEY_B"
          else
            CURRENT_KEY="KEY_A"
            YOUTUBE_STREAM_KEY="$YOUTUBE_STREAM_KEY_A"
            echo "üîÑ Switching from KEY_B to KEY_A"
          fi
          
          # UPDATE ALL KEY FILES BEFORE STREAM STARTS (Ensures consistency)
          echo "üìù Updating ALL key files to: $CURRENT_KEY"
          for key_file in "${KEY_FILE_NAMES[@]}"; do
            echo "$CURRENT_KEY" > "$key_file"
            echo "  ‚úì Updated: $key_file"
          done
          
          # VERIFY all files have the same content
          echo "üîç Verifying all key files consistency..."
          for key_file in "${KEY_FILE_NAMES[@]}"; do
            if [ -f "$key_file" ]; then
              CONTENT=$(cat "$key_file")
              if [ "$CONTENT" = "$CURRENT_KEY" ]; then
                echo "  ‚úì $key_file: $CONTENT"
              else
                echo "  ‚úó $key_file mismatch: '$CONTENT' vs '$CURRENT_KEY'"
                # Force correction
                echo "$CURRENT_KEY" > "$key_file"
              fi
            fi
          done
          
          # Set outputs for later use
          echo "current-key=$CURRENT_KEY" >> $GITHUB_OUTPUT
          echo "youtube-stream-key=$YOUTUBE_STREAM_KEY" >> $GITHUB_OUTPUT
          echo "key-files-updated=true" >> $GITHUB_OUTPUT
          
          echo "========================================"
          echo "üéØ Selected key: $CURRENT_KEY"
          echo "üîë Stream key: ${YOUTUBE_STREAM_KEY:0:8}..."
          echo "========================================"

      - name: üîß Install FFmpeg
        run: |
          echo "========================================"
          echo "üîß FFMPEG INSTALLATION PHASE"
          echo "========================================"
          sudo apt update
          sudo apt install -y ffmpeg
          echo "‚úÖ FFmpeg installation complete"
          ffmpeg -version

      - name: üé≤ Select random video
        id: random-video
        run: |
          echo "========================================"
          echo "üé≤ RANDOM VIDEO SELECTION PHASE"
          echo "========================================"
          RANDOM_NUM=$(( RANDOM % ($VIDEO_FILE_RANGE_END - $VIDEO_FILE_RANGE_START + 1) + $VIDEO_FILE_RANGE_START ))
          VIDEO_FILE="${VIDEO_FILE_PREFIX}${RANDOM_NUM}${VIDEO_FILE_EXTENSION}"
          echo "‚úÖ Selected video: $VIDEO_FILE"
          echo "video-file=$VIDEO_FILE" >> $GITHUB_OUTPUT

      - name: ‚è±Ô∏è Calculate runtime
        id: runtime
        run: |
          echo "========================================"
          echo "‚è±Ô∏è RUNTIME CALCULATION PHASE"
          echo "========================================"
          START_JITTER_SECONDS=$(( RANDOM % ($START_JITTER_MAX * 60 + 1) ))
          END_JITTER_SECONDS=$(( RANDOM % ($END_JITTER_MAX * 60 + 1) ))
          TOTAL_SECONDS=$(( BASE_RUNTIME * 60 + START_JITTER_SECONDS + END_JITTER_SECONDS ))
          
          echo "‚ÑπÔ∏è  Base runtime: $BASE_RUNTIME minutes"
          echo "‚ÑπÔ∏è  Start jitter: $START_JITTER_SECONDS seconds"
          echo "‚ÑπÔ∏è  End jitter: $END_JITTER_SECONDS seconds"
          echo "‚úÖ Total runtime: $TOTAL_SECONDS seconds"
          
          echo "start-jitter=$START_JITTER_SECONDS" >> $GITHUB_OUTPUT
          echo "total-runtime=$TOTAL_SECONDS" >> $GITHUB_OUTPUT

      - name: ‚è≥ Wait for start jitter
        run: |
          echo "========================================"
          echo "‚è≥ START JITTER DELAY PHASE"
          echo "========================================"
          echo "‚ÑπÔ∏è  Waiting for ${{ steps.runtime.outputs.start-jitter }} seconds..."
          sleep ${{ steps.runtime.outputs.start-jitter }}
          echo "‚úÖ Start jitter delay complete"

      - name: üü° Allow YouTube ingest preparation
        run: |
          echo "========================================"
          echo "üü° YOUTUBE PREPARATION DELAY"
          echo "========================================"
          echo "‚ÑπÔ∏è  Waiting ${YOUTUBE_PREP_DELAY} seconds for YouTube preparation..."
          sleep ${YOUTUBE_PREP_DELAY}
          echo "‚úÖ YouTube preparation delay complete"

      - name: üî¥ Stream to YouTube (STABLE & SAFE)
        run: |
          echo "========================================"
          echo "üî¥ STREAMING TO YOUTUBE"
          echo "========================================"
          echo "‚ÑπÔ∏è  Starting FFmpeg stream..."
          echo "üì∫ Video: ${{ steps.random-video.outputs.video-file }}"
          echo "üîë Stream key: ${{ steps.select-key.outputs.current-key }}"
          echo "‚è±Ô∏è  Duration: ${{ steps.runtime.outputs.total-runtime }} seconds"
          
          # Create a monitoring script that also logs key usage
          cat > stream_monitor.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          
          # Log key usage at start
          echo "======================================================================" >> key_usage.log
          echo "üöÄ STREAM STARTED: $(date)" >> key_usage.log
          echo "Key used: $CURRENT_KEY" >> key_usage.log
          echo "YouTube key: ${YOUTUBE_STREAM_KEY:0:8}..." >> key_usage.log
          echo "Video: $VIDEO_FILE" >> key_usage.log
          echo "======================================================================" >> key_usage.log
          
          # Run ffmpeg with detailed logging
          ffmpeg \
            -re \
            -fflags +genpts \
            -stream_loop -1 \
            -thread_queue_size 512 \
            -i "${CLOUDFLARE_R2_URL}${VIDEO_FILE}" \
            -r 30 -g 60 -keyint_min 60 -sc_threshold 0 \
            -force_key_frames "expr:gte(t,n_forced*2)" \
            -c:v libx264 -preset veryfast \
            -b:v 1500k -maxrate 1500k -bufsize 3000k \
            -pix_fmt yuv420p -profile:v high -level 4.2 \
            -c:a aac -b:a 96k \
            -ar 44100 -ac 2 \
            -af aresample=async=1:first_pts=0 \
            -f flv \
            -flvflags no_duration_filesize \
            -rtmp_live live \
            -reconnect 1 \
            -reconnect_streamed 1 \
            -reconnect_delay_max 2 \
            "${YOUTUBE_RTMP_URL}${YOUTUBE_STREAM_KEY}" 2>&1 | tee ffmpeg.log &
          
          FFMPEG_PID=$!
          
          # Monitor and log every 30 seconds
          (
            COUNTER=0
            while kill -0 $FFMPEG_PID 2>/dev/null && [ $COUNTER -lt $((TOTAL_RUNTIME + 60)) ]; do
              sleep 30
              COUNTER=$((COUNTER + 30))
              echo "‚è±Ô∏è  Stream running for $COUNTER/$TOTAL_RUNTIME seconds" >&2
            done
          ) &
          MONITOR_PID=$!
          
          # Wait for the runtime to complete
          sleep ${TOTAL_RUNTIME}
          
          # Log stream completion
          echo "======================================================================" >> key_usage.log
          echo "‚úÖ STREAM COMPLETED: $(date)" >> key_usage.log
          echo "Duration: $TOTAL_RUNTIME seconds" >> key_usage.log
          echo "======================================================================" >> key_usage.log
          
          # Gracefully stop ffmpeg
          kill -SIGINT $FFMPEG_PID
          wait $FFMPEG_PID || true
          kill $MONITOR_PID 2>/dev/null || true
          EOF
          
          chmod +x stream_monitor.sh
          
          export VIDEO_FILE="${{ steps.random-video.outputs.video-file }}"
          export TOTAL_RUNTIME="${{ steps.runtime.outputs.total-runtime }}"
          export YOUTUBE_STREAM_KEY="${{ steps.select-key.outputs.youtube-stream-key }}"
          export CURRENT_KEY="${{ steps.select-key.outputs.current-key }}"
          
          # Run the stream
          ./stream_monitor.sh
          
          echo "‚úÖ Stream completed successfully"

      - name: üíæ Commit and push ALL key states
        if: always()
        run: |
          echo "========================================"
          echo "üíæ COMMITTING ALL KEY STATES"
          echo "========================================"
          
          # Ensure all key files exist and are consistent
          KEY_FILES=("last_stream_key.txt" "last_key_stream.txt" "stream_key_state.txt")
          
          echo "üîç Checking key file consistency before commit..."
          for key_file in "${KEY_FILES[@]}"; do
            if [ -f "$key_file" ]; then
              echo "  üìÑ $key_file: $(cat $key_file)"
            else
              echo "  ‚ö†Ô∏è  $key_file not found, creating..."
              echo "${{ steps.select-key.outputs.current-key }}" > "$key_file"
            fi
          done
          
          # Add and commit all key files
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Force add all key files
          for key_file in "${KEY_FILES[@]}"; do
            git add "$key_file" -f
          done
          
          # Also add the key usage log
          if [ -f "key_usage.log" ]; then
            git add "key_usage.log" -f
          fi
          
          # Create commit message with key rotation info
          CURRENT_KEY="${{ steps.select-key.outputs.current-key }}"
          NEXT_KEY="KEY_B"
          if [ "$CURRENT_KEY" = "KEY_B" ]; then
            NEXT_KEY="KEY_A"
          fi
          
          COMMIT_MSG="üîÑ Stream key rotated: $CURRENT_KEY ‚Üí $NEXT_KEY
          
          - Current key: $CURRENT_KEY
          - Next key: $NEXT_KEY
          - Video: ${{ steps.random-video.outputs.video-file }}
          - Runtime: ${{ steps.runtime.outputs.total-runtime }} seconds
          - Timestamp: $(date)"
          
          echo "üíæ Committing changes..."
          git commit -m "$COMMIT_MSG" || echo "‚ö†Ô∏è  No changes to commit"
          
          echo "üöÄ Pushing changes to repository..."
          # Try multiple push methods for redundancy
          git push origin HEAD:${{ github.ref_name }} || \
          git push --force origin HEAD:${{ github.ref_name }} || \
          echo "‚ö†Ô∏è  Push failed, but key files are updated locally"
          
          echo "‚úÖ All key states committed and pushed"

      - name: üìä Log final state
        if: always()
        run: |
          echo "========================================"
          echo "üìä FINAL STATE VERIFICATION"
          echo "========================================"
          
          # Check all key files
          echo "üîë CURRENT KEY FILES STATE:"
          echo "----------------------------------------"
          for key_file in last_stream_key.txt last_key_stream.txt stream_key_state.txt; do
            if [ -f "$key_file" ]; then
              echo "$key_file: $(cat $key_file)"
            else
              echo "$key_file: ‚ùå MISSING"
            fi
          done
          
          CURRENT_KEY="${{ steps.select-key.outputs.current-key }}"
          NEXT_KEY="KEY_B"
          if [ "$CURRENT_KEY" = "KEY_B" ]; then
            NEXT_KEY="KEY_A"
          fi
          
          echo ""
          echo "üéØ KEY ROTATION STATUS:"
          echo "----------------------------------------"
          echo "‚úì Stream completed with: $CURRENT_KEY"
          echo "‚úì Next stream will use: $NEXT_KEY"
          echo ""
          echo "üìä PERFORMANCE SUMMARY:"
          echo "----------------------------------------"
          echo "‚Ä¢ Video played: ${{ steps.random-video.outputs.video-file }}"
          echo "‚Ä¢ Total runtime: ${{ steps.runtime.outputs.total-runtime }} seconds"
          echo "‚Ä¢ Start jitter: ${{ steps.runtime.outputs.start-jitter }} seconds"
          echo "‚Ä¢ Stream keys alternated: ‚úÖ ENSURED"
          echo ""
          echo "‚ö†Ô∏è  VERIFICATION:"
          echo "----------------------------------------"
          echo "All key files checked and synchronized"
          echo "Git commit pushed for state persistence"
          echo "Next run will use the opposite key"
          
          # Final verification
          ALL_FILES_CONSISTENT=true
          EXPECTED_KEY="$NEXT_KEY"  # After rotation
          
          for key_file in last_stream_key.txt last_key_stream.txt stream_key_state.txt; do
            if [ -f "$key_file" ]; then
              ACTUAL_KEY=$(cat "$key_file")
              if [ "$ACTUAL_KEY" != "$EXPECTED_KEY" ]; then
                echo "‚ùå $key_file: MISMATCH (has: $ACTUAL_KEY, expected: $EXPECTED_KEY)"
                ALL_FILES_CONSISTENT=false
              fi
            fi
          done
          
          if [ "$ALL_FILES_CONSISTENT" = "true" ]; then
            echo "‚úÖ ALL KEY FILES ARE CONSISTENT AND READY FOR NEXT STREAM"
          else
            echo "‚ö†Ô∏è  SOME KEY FILES NEED MANUAL VERIFICATION"
          fi
          
          echo "========================================"
          echo "üéâ STREAM WORKFLOW COMPLETE"
          echo "========================================"
